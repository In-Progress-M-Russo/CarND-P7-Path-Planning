## Path Planning Project
The goal of this project is the implementation, in C++, of a path planning algorythm able to navigate a vehicle around a virtual highway with other traffic that is driving +-10 MPH of the 50 MPH speed limit. The car stays as close as possible to the 50 MPH speed limit, passing slower traffic when possible. The path planner will avoid colliding with other cars and will keep the Ego vehicle inside of the marked road lanes at all times, unless going from one lane to another. The trajectories generated by the planner will also keep total acceleration below 10 m/s^2 and total jerk below than 10 m/s^3.

The source code is contained in the [src](./src) folder in this git repo. It is the evolution of a starter project provided directly by Udacity, where the [`main.cpp`](./src/main.cpp) file was modified and few files (most notably [`vehicle.cpp`](./src/vehicle.cpp) and [`vehicle.h`](./src/vehicle.h)) were added.

The following sections of this writeup will provide details on the filter operations and the data flow, and in doing so the fundamental pieces of the code will be explained. A final [Results](Path_Planning_writeup.md#Results) section will show the outcomes of the path planner running. 

---
## Data Input

The data source for this Filter will be the Udacity [simulator](https://github.com/udacity/self-driving-car-sim/releases/tag/T3_v1.2). The compiled code will open a websocket session to the sim to read localization information for the vehicles and provide back a trajectory to follow.

### _The Map_
A map of the highway is also provided in the [`highway_map.txt`](./data/highway_map.txt) file that can be found in the [data](./data) directory. 

Each waypoint in the list contains  [x,y,s,dx,dy] values. x and y are the waypoint's map coordinate position, the s value is the distance along the road to get to that waypoint in meters, the dx and dy values define the unit normal vector pointing outward of the highway loop.

The highway's waypoints loop around so the Frenet s value, distance along the road, goes from 0 to 6945.554.

---
## Code Structure
The code in [`main.cpp`](./src/main.cpp) has been modified mostly regarding the `onMessage` lambda function that gets ionvoked when a new message is available through the WebSocket connection open with the simulator (lines 70-236):

```sh
    h.onMessage([&ref_vel, &max_s, &ego_state, &ego_goal_lane, &init_acc_over,
               &map_waypoints_x,&map_waypoints_y,&map_waypoints_s,
               &map_waypoints_dx,&map_waypoints_dy]
              (uWS::WebSocket<uWS::SERVER> ws, char *data, size_t length,
               uWS::OpCode opCode) {
               
               ...              
    }
```

Within this function there are few more steps that can be found.

## Message Parsing
This is just the parsing of the various items in the message coming from the sim: can be found in lines 90-112 of [`main.cpp`](./src/main.cpp): 

```sh
    // ===================================================================
    // MESSAGE PARSING
    // Main car's localization Data
    double car_x = j[1]["x"];
    double car_y = j[1]["y"];
    double car_s = j[1]["s"];
    double car_d = j[1]["d"];
    double car_yaw = j[1]["yaw"];
    double car_speed = j[1]["speed"];

    // Previous path data given to the Planner and NOT yet executed by
    // the car
    vector<double> previous_path_x = j[1]["previous_path_x"];
    vector<double> previous_path_y = j[1]["previous_path_y"];
    // Previous path's end s and d values
    double end_path_s = j[1]["end_path_s"];
    double end_path_d = j[1]["end_path_d"];

    // Sensor Fusion Data, a list of all other cars on the same side
    //   of the road.
    auto sensor_fusion = j[1]["sensor_fusion"];

    json msgJson;
```

## Path Planning
The actual Path Planning phase starts on line 115. 

Both the Ego vehicle and the others on the road will be represented as `Vehicle` objects.

### _Vehicle Class_
The Vehicle class is defined through [`vehicle.h`](./src/vehicle.h) and [`vehicle.cpp`](./src/vehicle.cpp), and is the class containing the main methods for trajectory projection and selection. It is based on the definition of a `Vehicle` object identified by some fundamental attributes, as it can be seen from the contructor:

```sh
 /**
   * Constructor with parameters
   *
   * @param lane = id for the lane occupied by the vehicle
   * @param s = longitudinal Frenet coordinates for the vehicle
   * @param d = transverse Frenet coordinates for the vehicle
   * @param v = speed of the vehicle (in m/s)
   * @param a = acceleration of the vehicle
   * @param x = x-coordinate of the vehicle
   * @param y = y-coordinate of the vehicle
   * @param state = state of the vehicle (default = "CS")
   */
  Vehicle(int lane, float s, float d, float v, float a, float x, float y, float yaw, string state="CS");
```

These attributes will then be used by the various methods to identify a feasible trajectory.

The conditions of the vehicle on the road will be defined through 2 maps defined in `main.cpp` on lines 126-128:

```sh
   // Maps to be filled with the vehicles in the scene and their possible trajectories
   map<int, Vehicle> vehicles;
   map<int ,vector<Vehicle> > predictions;
```

The first one will be a snapshot of the vehicles as sensed, the second will contain some extrapolations of possible trajectories. The trajectory prediction is executed by the `generatePredictions` method in the Vehicle class, that for every vehicle observed, propagate a brief (30 sampling points) trajectory under the assumption of **constant speed**.

### _Trajectory Definition_
The definition of the trajectories is contained in the `generateXYTrajectory` method of the Vehicle class ([`vehicle.cpp`](/src/vehicle.cpp), lines 61-161) and makes use of what explained in the Udacity [video](https://www.youtube.com/watch?v=7sI3VHFPP0w&feature=emb_logo) supporting the project.

The most notable features of the approach are:

* Trajectories are defined as splines. Even if not formally proven as for the 5th order polynomial case, this solution has demonstrated to be capable of satisfying requirements on smoothness of the trajectory, avoing spikes in acceleration and jerk. Splines are implemented using resources available [here](http://kluge.in-chemnitz.de/opensource/spline/); the spline function is in a single header file ([`spline.h`](./src/spline.h)). 
* At every planning step, the generated trajectory is an extension of the previous path data given to the Planner. This is part of the message provided by the simulator (see previous section) and using it avoids discontinuities in the generation process.
* Part of the trajectory projection includes a check for possible collision with a vehicle ahead on the same lane: if that's the case the reference velocity of the Ego vehicle gets modified, in order to slow it doown and avoid the collision. Velocity regulation is contained in the `regulateVelocity` method ([`vehicle.cpp`](/src/vehicle.cpp), lines 411-478). 
* An initial acceleration phase is also foreseen to allow the Ego vehicle to move from idle to a reference speed of 49.5 MPH. No lane changes are intended to happen until this phase is over.
 

### _The Finite States Machine (FSM)_
The decision whether or not the Ego vehicle should stay in the lane it is or attempt a lanne change is based on a simple FSM that normally considers only 3 states:

State | Definition
---- | ----
`KL` | Keep Lane (regulating speed as needed)
`LCL` | Lane Change to the Left
`LCR` | Lane Change to the Right

* At every sampling instant the trajectories for all the possble states are generated and a cost function is associated to enable a transition. This is contained in the `implementNextTrajectory` method ([`vehicle.cpp`](/src/vehicle.cpp), lines 180-398).
* The transition between the states id regulated by cost function that will privilege KL with respect to LCL with respect to LCR.
* Stayning in a lane will be penalised if a reduction in speed is needed; lane changes will be penalised if there is a risk of collision.
* The risk of collision in case of lane change is evaluated calculating the distance between the points of a lane change trajectory and the projected trajectories for the non-Ego vehicles. These distance is then compared to a reference distance that depends on the speed of the Ego vehicle, being 10 meters when the vehicle is at the reference speed of 49.5 MPH. See, for example, the LCL use case in the `implementNextTrajectory` method in [`vehicle.cpp`](./src/vehicle.cpp), lines 265-266: 

```sh
     // Reference distance calculated as a function of the velocity of the Ego vehicle (r_vel)
     float ref_dist_LCL = (REF_SPEED/std::max(r_vel,0.1))*REF_DIST_LC;
```
*NOTE*: Some constants (`REF_SPEED`, `REF_DIST_LC` are defined together with helper methods in [`helpers.h`](./src/helpers.h).

* In case the vehicle is in the leftmost/rightmost lane, only LCR/LCL changes are allowed, respectively. The possible successor states for any moment in time are calculated in the `successorStates` method ([`vehicle.cpp`](/src/vehicle.cpp), lines 489-522).

---
## Results
Examples of the trajectories enabled by this path planner can be found in the following videos:


    
[![Example 1](http://img.youtube.com/vi/RVlWi51o3y8/0.jpg)](https://www.youtube.com/watch?v=RVlWi51o3y8 "Example 1")

[![Example 2](http://img.youtube.com/vi/K7TrOyOc7bk/0.jpg)](https://www.youtube.com/watch?v=K7TrOyOc7bk "Example 2")

    
In both cases (relative to different simulated scenario) is possible to see how the current path planner implementation reaches the intended target of driving for around 5 miles along the track without accidents (collision or eccessive accelerations/jerks).

Of course this does not mean that improvements are not possible. For example, few options could be:

* Improve the FSM both in the sense of including preparatory states before the actual LCL/LCR (to allow more complex maneuvers), and refine the definition of the cost functions. Examples could include the evaluation of the speed in the lanes (so to change towards the faster) or the actual distance to a vehicle in front _after_ the change takes place (so to change towards the one with the bigger distance as an indicator of safety).
* Remove/modify the hypothesis of constant speed for other vehicles when projecting their trajectories. This could be done by storing their past states and building some different models for their behavior. The current hypothesis is indeed _not_ respected by the simulator, and, even if working in the majority of cases (given the limited time horizon for the projection) it required the introduction of an "emergency brake" feature in the velocity regulation section, so to deal with sudden lane changes of the preceding vehicles. This feature, however, can generate accelerations beyond the intended threshold: an example of such a scenario is shown in the following video (t = 3 min):

[![Emergency Brake Example](http://img.youtube.com/vi/a1XyU_aDV-s/0.jpg)](https://www.youtube.com/watch?v=a1XyU_aDV-s "Emergency Brake Example")

* Improve the velocity regulation mechanism. At the moment the seqence of acceleration/deceleration phases can lead to some sort of "yo-yo" motion (visible in all the videos above) when lane changes are not possible and the vehicle ahead is slower than the ref. speed. This mechanism could be modified to allow the Ego vehicle to change its reference speed to the one of the lane it's in, when changes are not possible.
