## Path Planning Project
The goal of this project is the implementation, in C++, of a path planning algorythm able to navigate a vehicle around a virtual highway with other traffic that is driving +-10 MPH of the 50 MPH speed limit. The car stays as close as possible to the 50 MPH speed limit, passing slower traffic when possible. The path planner will avoid colliding with other cars and will keep the Ego vehicle inside of the marked road lanes at all times, unless going from one lane to another. The trajectories generated by the planner will also keep total acceleration below 10 m/s^2 and total jerk below than 10 m/s^3.

The source code is contained in the [src](./src) folder in this git repo. It is the evolution of a starter project provided directly by Udacity, where the [`main.cpp`](./src/main.cpp) file was modified and few files (most notably [`vehicle.cpp`](./src/vehicle.cpp) and [`vehicle.h`](./src/vehicle.h)) were added.

The following sections of this writeup will provide details on the filter operations and the data flow, and in doing so the fundamental pieces of the code will be explained. A final [Results](Path_Planning_writeup.md#Results) section will show the outcomes of the path planner running. 

---
## Data Input

The data source for this Filter will be the Udacity [simulator](https://github.com/udacity/self-driving-car-sim/releases/tag/T3_v1.2). The compiled code will open a websocket session to the sim to read localization information for the vehicles and provide back a trajectory to follow.

### _The Map_
A map of the highway is also provided in the [`highway_map.txt`](./data/highway_map.txt) file that can be found in the [data](./data) directory. 

Each waypoint in the list contains  [x,y,s,dx,dy] values. x and y are the waypoint's map coordinate position, the s value is the distance along the road to get to that waypoint in meters, the dx and dy values define the unit normal vector pointing outward of the highway loop.

The highway's waypoints loop around so the Frenet s value, distance along the road, goes from 0 to 6945.554.

---
## Code Structure
The code in [`main.cpp`](./src/main.cpp) has been modified mostly regarding the `onMessage` lambda function that gets ionvoked when a new message is available through the WebSocket connection open with the simulator (lines 70-236):

```sh
    h.onMessage([&ref_vel, &max_s, &ego_state, &ego_goal_lane, &init_acc_over,
               &map_waypoints_x,&map_waypoints_y,&map_waypoints_s,
               &map_waypoints_dx,&map_waypoints_dy]
              (uWS::WebSocket<uWS::SERVER> ws, char *data, size_t length,
               uWS::OpCode opCode) {
               
               ...              
  }
```

Within this function there are few more steps that can be found.

## Message Parsing
This is just the parsing of the various items in the message coming from the sim: can be found in lines 90-112 of [`main.cpp`](./src/main.cpp): 

```sh
    // ===================================================================
    // MESSAGE PARSING
    // Main car's localization Data
    double car_x = j[1]["x"];
    double car_y = j[1]["y"];
    double car_s = j[1]["s"];
    double car_d = j[1]["d"];
    double car_yaw = j[1]["yaw"];
    double car_speed = j[1]["speed"];

    // Previous path data given to the Planner and NOT yet executed by
    // the car
    vector<double> previous_path_x = j[1]["previous_path_x"];
    vector<double> previous_path_y = j[1]["previous_path_y"];
    // Previous path's end s and d values
    double end_path_s = j[1]["end_path_s"];
    double end_path_d = j[1]["end_path_d"];

     // Sensor Fusion Data, a list of all other cars on the same side
     //   of the road.
     auto sensor_fusion = j[1]["sensor_fusion"];

     json msgJson;
```

## Path Planning
The actual Path Planning phase starts on line 117. 

Both the Ego vehicle and the others on the road will be represented as `Vehicle` objects.

### _Vehicle Class_
The vehicle class is defined through [`vehicle.h`](./src/vehicle.h) and [`vehicle.cpp`](./src/vehicle.cpp), and is the class containing the main methods for trajectory projection and selection. It is based on the definition of a `Vehicle` object identified by some fundamental attributes, as it can be seen from the contructor:

```sh
 /**
   * Constructor with parameters
   *
   * @param lane = id for the lane occupied by the vehicle
   * @param s = longitudinal Frenet coordinates for the vehicle
   * @param d = transverse Frenet coordinates for the vehicle
   * @param v = speed of the vehicle (in m/s)
   * @param a = acceleration of the vehicle
   * @param x = x-coordinate of the vehicle
   * @param y = y-coordinate of the vehicle
   * @param state = state of the vehicle (default = "CS")
   */
  Vehicle(int lane, float s, float d, float v, float a, float x, float y, float yaw, string state="CS");
```

These attributes will then be used by the various methods, to identify a feasible trajectory.

The conditions of the vehicle on the road will be defined through 2 maps defined in `main.cpp` on lines 128-130:

```sh
   // Maps to be filled with the vehicles in the scene and their possible trajectories
   map<int, Vehicle> vehicles;
   map<int ,vector<Vehicle> > predictions;
```

The first one will be a snapshot of the vehicles as sensed, the second will contain some extrapolations of possible trajectories. The trajectory prediction is executed by the `generatePredictions` method in the Vehicle class, that for every vehicle observed, propagate a brief (30 sampling points) trajectory under the assumption of **constant speed**.

### _Trajectory Definition_
The definition of the trajectories makes use of what explained in the Udacity [video](https://www.youtube.com/watch?v=7sI3VHFPP0w&feature=emb_logo) supporting the project. 

The most notable features of the approach are:

* Trajectories are defined as splines. Even if not formally proven as for the 5th order polynomial case, this solution has demonstrated to be capable of satisfying requirements on smoothness of the trajectory, avoing spikes in acceleration and jerk. Splines are implemented using resources available [here](http://kluge.in-chemnitz.de/opensource/spline/); the spline function is in a single header file ([`spline.h`](./src/spline.h)). 
* At every planning step, the generated trajectory is an extension of the previous path data given to the Planner. This is part of the message provided by the simulator (see previous section) and using it avoids discontinuities in the generation process.
* Part of the trajectory projection includes a check for possible collision with a vehicle ahead on the same lane: if that's the case the reference velocity of the Ego vehicle gets modified, in order to slow it doown and avoid the collision. 
 

### _The Finite States Machine (FSM)_
In every moment the trajectory to follow is picked based on a simple FSM that normally considers only 3 states:

State | Definition
---- | ----
`KL` | Keep Lane (regulating speed as needed)
`LCL` | Lane Change to the Left
`LCR` | Lane Change to the Right

* The transition between the states id regulated by cost function that will privilege KL with respect to LCL with respect to LCR.
* Stayning in a lane will be penalised if a reduction in speed is needed; lane changes will be penalised if there is a risk of collision.
* The risk of collision in case of lane change is evaluated calculating the distance between the points of a lane change trajectory and the projected trajectories for the non-Ego vehicles. These distance is then compared to a reference distance that depends on the speed of the Ego vehicle, being 10 meters when the vehicle is at the reference speed of 49.5 MPH. See, for example, the LCL use case in the `implementNextTrajectory` method in [`vehicle.cpp`](./src/vehicle.cpp), lines 154-155: 

```sh
     // Reference distance calculated as a function of the velocity of the Ego vehicle (r_vel)
     float ref_dist_LCL = (REF_SPEED/std::max(r_vel,0.1))*REF_DIST_LC;
```
*NOTE*: Some constants (`REF_SPEED`, `REF_DIST_LC` are defined together with helper methods in [`helpers.h`](./src/helpers.h).

* In case the vehicle is in the leftmost/rightmost lane, only LCR/LCL changes are allowed, respectively.

---
## Results
Examples of the trajectories enabled by this path planner can be found in the following videos:

[![Trajectory 1](http://img.youtube.com/vi/pqqxOBk2FOg/0.jpg)](https://www.youtube.com/watch?v=pqqxOBk2FOg "Trajectory 1")

---


